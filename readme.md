Fase 2 — Persistência com JPA

RESUMO: MANY TO ONE É O REI DO JPA (ver mais em pessoa ~ sinonimo), TRANSACTIONAL (TUDO OU NADA), JOIN FETCH EVITAR N+1. LEMBRAR QUE SAVE É OPCIONAL EM METODO COM @TRANSACTIONAL, A MENOS QUE SEJA CRIANDO NOVO RECURSO E USAR HASH AND EQUALS SOMENTE COM ID NA ENTIDADE.

A Fase 2 introduz a persistência de dados e, com ela, uma das maiores fontes de problemas em aplicações backend mal estruturadas. Até aqui, o foco esteve na organização do código e no fluxo da aplicação. A partir deste ponto, suas decisões começam a impactar diretamente performance, consistência de dados e estabilidade em produção. O objetivo desta fase não é “aprender JPA por completo”, mas dominar o uso prático e seguro do Hibernate e do Spring Data JPA para resolver problemas reais, evitando armadilhas comuns que afetam aplicações em médio e longo prazo.
A modelagem de domínio com JPA é o primeiro grande passo. Diferente de simples classes Java, entidades representam dados persistidos e, portanto, carregam implicações importantes. Um erro comum de iniciantes é tratar entidades como DTOs ou como simples estruturas de dados. Em sistemas profissionais, entidades representam o modelo de domínio, ou seja, conceitos centrais do negócio. Elas devem ser claras, coesas e relativamente estáveis. Nesta fase, o foco deve estar em entender como mapear corretamente classes para tabelas, escolher identificadores adequados e evitar exageros como heranças complexas ou entidades genéricas demais. Não é necessário estudar todos os tipos de mapeamento existentes; o essencial é saber criar entidades simples, legíveis e alinhadas ao problema que o sistema resolve.
Os relacionamentos entre entidades são outro ponto crítico. JPA oferece várias opções, mas no dia a dia profissional, a maior parte dos sistemas utiliza apenas alguns padrões bem definidos. Relacionamentos @ManyToOne e @OneToMany são extremamente comuns e, ao mesmo tempo, grandes fontes de bugs quando mal utilizados. O objetivo aqui não é decorar anotações, mas entender como o Hibernate carrega dados, como chaves estrangeiras funcionam e como decisões aparentemente pequenas podem gerar consultas ineficientes. Relações bidirecionais devem ser usadas com cuidado, sempre com consciência do impacto que têm na serialização e no carregamento de dados.
O uso do Spring Data JPA e do JpaRepository é o que torna o trabalho com persistência realmente produtivo. Em ambientes profissionais, quase ninguém escreve DAOs manuais. O Spring Data abstrai grande parte do trabalho repetitivo, permitindo que o desenvolvedor foque em consultas específicas e regras de negócio. Métodos derivados por nome cobrem a maioria das necessidades básicas, e consultas JPQL simples resolvem casos mais específicos. Nesta fase, o objetivo não é escrever queries complexas ou altamente otimizadas, mas entender como expressar corretamente intenções de busca e leitura de dados sem recorrer a soluções improvisadas.
O gerenciamento de transações é um dos aspectos mais importantes e menos compreendidos por iniciantes. Em produção, transações mal definidas causam dados inconsistentes, erros intermitentes e comportamentos difíceis de reproduzir. O uso do @Transactional deve ser consciente e, na maioria dos casos, restrito à camada de service. Controllers não devem gerenciar transações, e repositories não devem conter lógica de negócio. Nesta fase, o essencial é entender que uma transação delimita um contexto de consistência e que ela precisa englobar todas as operações que fazem parte de uma mesma regra de negócio.
A compreensão prática de carregamento Lazy e Eager é absolutamente fundamental. Muitos problemas de performance em sistemas Spring surgem não por falta de hardware, mas por uso incorreto de relacionamentos e carregamento automático de dados. O Lazy loading deve ser o padrão mental, pois evita trazer dados desnecessários do banco. O Eager loading, quando usado sem critério, gera consultas grandes, lentas e difíceis de prever. Associado a isso, o problema conhecido como N+1 aparece com frequência em aplicações mal modeladas. Nesta fase, o objetivo não é decorar soluções avançadas, mas aprender a identificar quando o problema ocorre, entender por que ele acontece e saber aplicar soluções simples, como ajustes de consulta ou reestruturação de acesso aos dados.
O estudo da Fase 2 deve ser sempre guiado por exemplos concretos e observação do comportamento real da aplicação. Ver as queries geradas, entender quando o banco é acessado e perceber o impacto de cada decisão é muito mais importante do que memorizar anotações. Ferramentas de log de SQL são aliadas importantes neste momento, pois ajudam a criar intuição sobre o funcionamento do ORM.
Para consolidar essa fase, o projeto iniciado anteriormente deve evoluir para utilizar um banco relacional real, como PostgreSQL ou MySQL. As entidades devem ser persistidas corretamente, os repositories devem refletir necessidades reais de busca e os services devem controlar transações de forma explícita quando necessário. DTOs continuam sendo obrigatórios, reforçando a separação entre modelo interno e contrato da API. O uso do Git permanece parte do processo, com commits representando mudanças claras na modelagem ou no comportamento de persistência.
Você pode considerar a Fase 2 concluída quando conseguir modelar entidades sem insegurança, quando entender por que uma consulta está lenta ao observar o SQL gerado, quando souber evitar o problema de N+1 de forma consciente e quando o uso de @Transactional fizer sentido lógico dentro do fluxo da aplicação. A partir desse ponto, sua API deixa de ser apenas bem estruturada e passa a ser realmente funcional em produção, abrindo espaço para a Fase 3, onde o foco se desloca para robustez, qualidade de contrato e experiência de consumo da API.

